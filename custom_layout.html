<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>Custom Layout Generator (Per-Page Input)</title>
  <style>
    /* Import custom font */
    @font-face {
      font-family: 'URWGroteskWid-Lig';
      src: url('URWGroteskWid-Lig.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
    }

    /* Center the main heading */
    h1 {
      text-align: center;
      margin: 20px 0;
      font-family: 'URWGroteskWid-Lig', sans-serif;
    }

    body {
      margin: 0;
      padding: 20px;
      overflow-x: auto;
      font-family: Arial, sans-serif;
      background-color: #f5f5f5;
    }

    /* 自定义布局区域 - 横向排列多个页面 */
    .custom-layout-area {
      margin-left: 20px;
      display: flex;
      gap: 20px;
      padding: 20px;
      overflow-x: auto;
      min-height: 920px;
      box-sizing: border-box;
       /* 关键修改：将 justify-content 改为 center，使展示区域水平居中 */
      justify-content: center;
    }

    .layout-container {
      width: 1700px;
      height: 820px;
      box-sizing: border-box;
      display: flex;
      gap: 100px; /* 左右容器间隔100px */
      position: relative;
    }

    .left-container,
    .right-container {
      width: 800px;
      height: 820px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      border: 2px dashed #dee2e6;
      border-radius: 8px;
      position: relative;
      background-color: #fafafa;
    }

    /* 居中对齐 */
    .left-container, .right-container {
      justify-content: center;
      align-items: center;
    }

    .image-container {
      width: 100%;
      display: flex;
      justify-content: center;
      margin-bottom: 20px;
    }

    .image-placeholder {
      width: 800px;
      height: 460px;
      background-color: #f0f0f0;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 24px;
      color: #999;
      border: 2px solid #ddd;
    }

    /* 段落基础样式 */
    .paragraph {
      font-family: 'URWGroteskWid-Lig', sans-serif;
      font-size: 41px;
      font-weight: normal;
      line-height: 50px;
      letter-spacing: 0px;
      word-wrap: break-word;
      width: 100%;
      margin-bottom: 30px;
    }

    .paragraph:last-child {
      margin-bottom: 0;
    }

    /* 自定义布局控制面板 */
    .custom-control-panel {
      width: 1800px;
      margin: 20px auto;
      padding: 20px;
      background-color: #fff;
      border-radius: 8px;
      box-sizing: border-box;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .page-layout-options {
      display: flex;
      gap: 15px;
      margin: 15px 0;
    }

    .page-layout-option {
      padding: 8px 15px;
      border: 1px solid #ddd;
      border-radius: 4px;
      cursor: pointer;
    }

    .page-layout-option.selected {
      background-color: #165DFF;
      color: white;
      border-color: #165DFF;
    }

    .page-input-group {
      margin-bottom: 15px;
    }

    .page-input-group label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
    }

    .page-input-group input {
      width: 100px;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }

    .row {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
    }

    .column {
      flex: 1;
    }

    textarea {
      width: 100%;
      height: 150px;
      padding: 12px;
      box-sizing: border-box;
      font-size: 14px;
      line-height: 1.5;
      font-family: monospace;
      border: 1px solid #ddd;
      border-radius: 4px;
      resize: vertical;
    }

    button {
      padding: 10px 20px;
      font-size: 14px;
      margin-top: 10px;
      cursor: pointer;
      border: none;
      border-radius: 4px;
      transition: background-color 0.3s;
    }

    .primary-btn {
      background-color: #165DFF;
      color: white;
    }

    .primary-btn:hover {
      background-color: #0E42CC;
    }

    .secondary-btn {
      background-color: #6c757d;
      color: white;
      margin-left: 10px;
    }

    .secondary-btn:hover {
      background-color: #5a6268;
    }

    /* Hidden measurement container - for accurate text height calculation */
    #measureContainer {
      position: absolute;
      visibility: hidden;
      width: 800px;
      font-family: 'URWGroteskWid-Lig', sans-serif;
      font-size: 41px;
      line-height: 50px;
      word-wrap: break-word;
      top: -1000px;
    }

    #measureContainer .paragraph {
      font-family: 'URWGroteskWid-Lig', sans-serif;
      font-size: 41px;
      font-weight: normal;
      line-height: 50px;
      letter-spacing: 0px;
      word-wrap: break-word;
      margin-bottom: 30px;
    }

    #measureContainer .paragraph:last-child {
      margin-bottom: 0;
    }
    
    /* Loading indicator */
    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255,255,255,.3);
      border-radius: 50%;
      border-top-color: white;
      animation: spin 1s ease-in-out infinite;
      margin-right: 8px;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* 超出指示器 - 改进样式 */
    .overflow-indicator {
      position: absolute;
      bottom: -30px;
      left: 0;
      width: 100%;
      text-align: center;
      color: #ff4d4f;
      font-size: 20px;
      font-weight: bold;
      font-family: sans-serif;
      text-transform: uppercase;
    }
    
    /* 页面级溢出提示 */
    .page-overflow-indicator {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(255, 77, 79, 0.9);
      color: white;
      padding: 10px 20px;
      border-radius: 4px;
      font-size: 24px;
      font-weight: bold;
      z-index: 10;
    }
    
    /* 内容包装器 - 用于居中内容 */
    .content-wrapper {
      width: 100%;
      max-height: 100%;
      overflow: hidden;
      position: relative;
    }
    
    /* 文本容器 - 用于控制文本溢出 */
    .text-container {
      width: 100%;
      position: relative;
    }
    
    /* 页面容器 */
    .custom-page {
      flex-shrink: 0;
      min-width: 1800px;
      height: 920px;
      margin: 0;
      position: relative;
      border: 1px solid #ccc;
      background-color: #fff;
      box-sizing: border-box;
      padding: 50px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }

    .page-number {
      position: absolute;
      top: 10px;
      right: 20px;
      font-size: 18px;
      color: #666;
      font-weight: bold;
    }
    
    /* 每页配置区域样式 */
    .page-config-section {
      margin-bottom: 30px;
      padding-bottom: 20px;
      border-bottom: 1px solid #eee;
    }

    .page-config-section:last-child {
      border-bottom: none;
      margin-bottom: 10px;
      padding-bottom: 0;
    }

    .page-config-header {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 15px;
      color: #333;
    }

    /* 初始提示样式 */
    .initial-prompt {
      font-size: 18px;
      color: #666;
      text-align: center;
      padding: 50px 0;
      height: 820px;
      box-sizing: border-box;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    

    /* Tab容器样式：控制按钮整体位置，与原页面宽度对齐 */
    .tab-container {
      width: 1800px; 
      margin: 0 auto; 
      padding-top: 20px; 
    }

    .tab-btn {
      padding: 10px 25px;
      font-size: 16px;
      border: none; 
      border-radius: 4px 4px 0 0; 
      cursor: pointer; 
      background-color: #f0f0f0; 
      transition: background-color 0.3s; 
      margin-right: 5px; 
    }


    .tab-btn.active {
      background-color: #165DFF; 
      color: white; 
      font-weight: 500;
    }

    .tab-btn:hover:not(.active) {
      background-color: #e0e0e0; 
    }

  </style>
</head>

<body>
  <!-- Tab按钮容器：包裹两个切换按钮 -->
  <div class="tab-container">
    <button class="tab-btn" id="batchModifyBtn">batch modify</button>
    <button class="tab-btn active" id="customModifyBtn">custom modify</button>
  </div>
  
  <h1>Custom Layout Generator (Per-Page Input)</h1>

  <!-- 自定义布局内容区域 -->
  <div id="customLayoutContent">
    <!-- 自定义布局显示区域 - 横向排列多个页面 -->
    <div class="custom-layout-area" id="customLayoutDisplay">
      <div class="initial-prompt">Please set the number of pages first, then configure each page's layout and text</div>
    </div>

    <!-- 自定义布局控制面板 -->
    <div class="custom-control-panel">
      <!-- 页面数量设置 -->
      <div class="page-input-group">
        <label for="pageCount">Set Number of Pages</label>
        <input type="number" id="pageCount" min="1" value="2">
        <button id="generatePageConfigsBtn" class="primary-btn">Generate Page Configurations</button>
      </div>

      <!-- 每页配置区域（动态生成） -->
      <div id="perPageConfigsContainer" style="display: none;">
        <!-- 每页配置项将在这里动态生成 -->
      </div>

      <!-- 整体预览按钮（动态显示） -->
      <div id="globalPreviewContainer" style="display: none; margin-top: 20px;">
        <button id="globalPreviewBtn" class="primary-btn">
          <span id="globalBtnText">Preview All Pages</span>
          <span id="globalLoadingIndicator" class="loading" style="display:none;"></span>
        </button>
      </div>
    </div>
  </div>

  <!-- Hidden measurement container - key for accurate text height calculation -->
  <div id="measureContainer"></div>

  <script>
    // Initialize page
    document.addEventListener('DOMContentLoaded', function () {
      // Set fixed zoom to 33%
      document.body.style.zoom = "33%";

      // Tab 按钮
      // 1. 获取Tab按钮（需确保HTML中已添加Tab按钮元素）
      const batchModifyBtn = document.getElementById('batchModifyBtn');
      const customModifyBtn = document.getElementById('customModifyBtn');

      // 2. batch modify按钮点击：切换到当前页面（保持样式激活）
      batchModifyBtn.addEventListener('click', function() {
        batchModifyBtn.classList.add('active');
        customModifyBtn.classList.remove('active');
        window.location.href = 'index.html'; // 子页面文件名需和实际一致
      });

      // 3. small modify按钮点击：跳转到子页面+切换样式
      customModifyBtn.addEventListener('click', function() {
        customModifyBtn.classList.add('active');
        batchModifyBtn.classList.remove('active');
      });

      
      // 核心元素引用
      const pageCountInput = document.getElementById('pageCount');
      const generatePageConfigsBtn = document.getElementById('generatePageConfigsBtn');
      const perPageConfigsContainer = document.getElementById('perPageConfigsContainer');
      const customLayoutDisplay = document.getElementById('customLayoutDisplay');
      const globalPreviewContainer = document.getElementById('globalPreviewContainer');
      const globalPreviewBtn = document.getElementById('globalPreviewBtn');
      const globalBtnText = document.getElementById('globalBtnText');
      const globalLoadingIndicator = document.getElementById('globalLoadingIndicator');

      // 存储每页配置数据（布局+文本）
      let pageConfigs = [];
      // 字体加载状态
      let fontLoaded = false;

      // 1. 生成每页配置区域 - 增加预览清空功能
      generatePageConfigsBtn.addEventListener('click', function() {
        // 清空上方页面预览区域，恢复初始提示
        customLayoutDisplay.innerHTML = '<div class="initial-prompt">Please set the number of pages first, then configure each page\'s layout and text</div>';
        
        const pageCount = parseInt(pageCountInput.value) || 1;
        pageConfigs = Array(pageCount).fill(null).map(() => ({ layout: 'pic+text', text: '' }));
        
        // 清空并生成每页配置项
        perPageConfigsContainer.innerHTML = '';
        perPageConfigsContainer.style.display = 'block';
        globalPreviewContainer.style.display = 'block';

        for (let i = 0; i < pageCount; i++) {
          const pageIndex = i + 1; // 页面序号（从1开始）
          const pageConfigSection = document.createElement('div');
          pageConfigSection.className = 'page-config-section';
          pageConfigSection.dataset.pageIndex = i;

          // 页面配置HTML结构
          pageConfigSection.innerHTML = `
            <div class="page-config-header">Page ${pageIndex} Configuration</div>
            <div class="row">
              <!-- 布局选择 -->
              <div class="column">
                <div class="page-input-group">
                  <label>Select Layout</label>
                  <div class="page-layout-options" data-page-index="${i}">
                    <div class="page-layout-option ${pageConfigs[i].layout === 'pic+text' ? 'selected' : ''}" data-layout="pic+text">pic+text</div>
                    <div class="page-layout-option ${pageConfigs[i].layout === 'text+text' ? 'selected' : ''}" data-layout="text+text">text+text</div>
                  </div>
                </div>
              </div>

              <!-- 文本输入 -->
              <div class="column">
                <div class="page-input-group">
                  <label>Enter Text for Page ${pageIndex} (Line breaks separate paragraphs)</label>
                  <textarea class="page-text-input" placeholder="Enter text content...">${pageConfigs[i].text || ''}</textarea>
                </div>
              </div>
            </div>

            <!-- 单页预览按钮 -->
            <button class="pagePreviewBtn primary-btn" data-page-index="${i}">
              Preview Page ${pageIndex}
            </button>
          `;

          perPageConfigsContainer.appendChild(pageConfigSection);

          // 绑定当前页布局选择事件
          const layoutOptions = pageConfigSection.querySelectorAll('.page-layout-option');
          layoutOptions.forEach(option => {
            option.addEventListener('click', function() {
              // 更新选中状态
              layoutOptions.forEach(opt => opt.classList.remove('selected'));
              this.classList.add('selected');
              // 保存布局配置
              const pageIdx = parseInt(this.closest('.page-layout-options').dataset.pageIndex);
              pageConfigs[pageIdx].layout = this.dataset.layout;
            });
          });

          // 绑定当前页文本输入事件
          const textInput = pageConfigSection.querySelector('.page-text-input');
          textInput.addEventListener('input', function() {
            const pageIdx = parseInt(this.closest('.page-config-section').dataset.pageIndex);
            pageConfigs[pageIdx].text = this.value.trim();
          });

          // 绑定当前页预览按钮事件
          const pagePreviewBtn = pageConfigSection.querySelector('.pagePreviewBtn');
          pagePreviewBtn.addEventListener('click', async function() {
            const pageIdx = parseInt(this.dataset.pageIndex);
            // 显示加载状态
            this.disabled = true;
            this.innerHTML = `<span class="loading" style="display:inline-block;"></span> Loading...`;
            
            try {
              // 确保字体加载完成
              if (!fontLoaded) await waitForFontLoad();
              // 预览当前页
              previewSinglePage(pageIdx);
            } finally {
              // 恢复按钮状态
              this.disabled = false;
              this.textContent = `Preview Page ${pageIdx + 1}`;
            }
          });
        }
      });

      // 2. 整体预览所有页面
      globalPreviewBtn.addEventListener('click', async function() {
        // 显示加载状态
        globalPreviewBtn.disabled = true;
        globalBtnText.textContent = 'Generating Preview...';
        globalLoadingIndicator.style.display = 'inline-block';
        
        try {
          // 确保字体加载完成
          if (!fontLoaded) await waitForFontLoad();
          // 预览所有页面
          previewAllPages();
        } finally {
          // 恢复按钮状态
          globalPreviewBtn.disabled = false;
          globalBtnText.textContent = 'Preview All Pages';
          globalLoadingIndicator.style.display = 'none';
        }
      });

      // 检查字体是否加载完成
      function checkFontLoaded() {
        // 创建测试元素
        const testElement = document.createElement('span');
        testElement.style.position = 'absolute';
        testElement.style.visibility = 'hidden';
        testElement.style.fontFamily = 'sans-serif';
        testElement.style.fontSize = '20px';
        testElement.textContent = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        
        const referenceElement = testElement.cloneNode(true);
        referenceElement.style.fontFamily = 'URWGroteskWid-Lig, sans-serif';
        
        document.body.appendChild(testElement);
        document.body.appendChild(referenceElement);
        
        // 如果宽度不同，说明字体已加载
        const isLoaded = testElement.offsetWidth !== referenceElement.offsetWidth;
        
        // 清理测试元素
        document.body.removeChild(testElement);
        document.body.removeChild(referenceElement);
        
        return isLoaded;
      }
      
      // 等待字体加载（带超时）
      function waitForFontLoad() {
        return new Promise((resolve) => {
          // 立即检查
          if (checkFontLoaded()) {
            fontLoaded = true;
            resolve(true);
            return;
          }
          
          // 定期检查
          const interval = setInterval(() => {
            if (checkFontLoaded()) {
              clearInterval(interval);
              fontLoaded = true;
              resolve(true);
            }
          }, 100);
          
          // 3秒超时
          setTimeout(() => {
            clearInterval(interval);
            console.warn('Font did not load within 3 seconds, using fallback');
            resolve(false);
            fontLoaded = true; // 强制标记为已加载，继续执行
          }, 3000);
        });
      }

      // 预览单页
      function previewSinglePage(pageIndex) {
        const pageConfig = pageConfigs[pageIndex];
        if (!pageConfig) return;
        
        // 清空显示区域并只显示当前页
        customLayoutDisplay.innerHTML = '';
        
        // 处理当前页内容
        const paragraphs = pageConfig.text 
          ? pageConfig.text.split(/\n+/).filter(para => para.trim() !== '').map(para => para.trim())
          : [];
        
        // 计算页面布局数据
        const pageData = calculatePageLayout(paragraphs, pageConfig.layout, pageIndex + 1);
        
        // 渲染页面
        const pageElement = renderPage(pageData, paragraphs);
        customLayoutDisplay.appendChild(pageElement);
      }

      // 预览所有页面
      function previewAllPages() {
        customLayoutDisplay.innerHTML = '';
        
        // 逐页处理并渲染
        pageConfigs.forEach((config, index) => {
          const paragraphs = config.text 
            ? config.text.split(/\n+/).filter(para => para.trim() !== '').map(para => para.trim())
            : [];
          
          const pageData = calculatePageLayout(paragraphs, config.layout, index + 1);
          const pageElement = renderPage(pageData, paragraphs);
          customLayoutDisplay.appendChild(pageElement);
        });
      }

      // 计算页面布局 - 重点修复text+text极端情况
      function calculatePageLayout(paragraphs, layout, pageNumber) {
        const pageData = {
          type: layout,
          left_paras: [],
          right_paras: [],
          pageNumber: pageNumber,
          overflow: false,
          all_paragraphs: [...paragraphs]
        };

        switch (layout) {
          case 'pic+text': {
            const imageHeight = 460;
            const imageGap = 20;
            const leftAvailableHeight = 820 - imageHeight - imageGap;
            const rightAvailableHeight = 820;

            // 填充左侧（图片下方）
            for (let i = 0; i < paragraphs.length; i++) {
              const tempParas = [...pageData.left_paras, paragraphs[i]];
              if (measureTextHeight(tempParas) <= leftAvailableHeight) {
                pageData.left_paras.push(paragraphs[i]);
              } else {
                break;
              }
            }
            const remainingParasAfterLeft = paragraphs.slice(pageData.left_paras.length);

            // 填充右侧空间
            for (let i = 0; i < remainingParasAfterLeft.length; i++) {
              const tempParas = [...pageData.right_paras, remainingParasAfterLeft[i]];
              if (measureTextHeight(tempParas) <= rightAvailableHeight) {
                pageData.right_paras.push(remainingParasAfterLeft[i]);
              } else {
                break;
              }
            }

            // 检查是否有文本未被放置（溢出）
            const placedParasCount = pageData.left_paras.length + pageData.right_paras.length;
            pageData.overflow = placedParasCount < paragraphs.length;

            // 极端情况处理：若文本能完全放到左侧，则将所有文本移至右侧
            if (!pageData.overflow) {
              const allText = [...pageData.left_paras, ...pageData.right_paras];
              const allTextHeight = measureTextHeight(allText);
              
              if (allTextHeight <= leftAvailableHeight) {
                pageData.right_paras = allText;
                pageData.left_paras = [];
              }
            }

            break;
          }

          case 'text+text': {
            const totalHeight = 820;
            const allParas = [...paragraphs];
            const allTextHeight = measureTextHeight(allParas);

            // 1. 特殊处理：只有1个段落的情况
            if (allParas.length === 1) {
              pageData.left_paras = [allParas[0]];
              pageData.right_paras = [];
              pageData.overflow = false;
              break;
            }

            // 2. 极端情况处理：所有文本能完全放入左侧时，采用均衡策略
            if (allTextHeight <= totalHeight && allParas.length > 1) {
              // 存储所有可能的分割方案
              const splitOptions = [];
              
              // 遍历所有可能的分割点（i从1到length-1），确保左侧至少1段，右侧至少1段
              for (let i = 1; i < allParas.length; i++) {
                const leftParas = allParas.slice(0, i);
                const rightParas = allParas.slice(i);
                
                const leftHeight = measureTextHeight(leftParas);
                const rightHeight = measureTextHeight(rightParas);
                
                // 计算高度差（左侧 - 右侧）
                const diff = leftHeight - rightHeight;
                
                // 只考虑左侧高度大于等于右侧的方案
                if (diff >= 0) {
                  splitOptions.push({
                    index: i,
                    leftHeight,
                    rightHeight,
                    diff: Math.abs(diff), // 存储差值绝对值用于比较
                    actualDiff: diff // 存储实际差值（左侧-右侧）
                  });
                }
              }
              
              // 如果没有符合条件的方案（左侧高度都小于右侧），则寻找最接近的方案
              if (splitOptions.length === 0) {
                for (let i = 1; i < allParas.length; i++) {
                  const leftParas = allParas.slice(0, i);
                  const rightParas = allParas.slice(i);
                  
                  const leftHeight = measureTextHeight(leftParas);
                  const rightHeight = measureTextHeight(rightParas);
                  
                  splitOptions.push({
                    index: i,
                    leftHeight,
                    rightHeight,
                    diff: Math.abs(leftHeight - rightHeight),
                    actualDiff: leftHeight - rightHeight
                  });
                }
              }
              
              // 找到最佳分割方案：优先选择左侧略大于右侧，且差值最小的
              splitOptions.sort((a, b) => {
                // 首先按是否左侧大于等于右侧排序
                if (a.actualDiff >= 0 && b.actualDiff < 0) return -1;
                if (a.actualDiff < 0 && b.actualDiff >= 0) return 1;
                
                // 再按差值绝对值排序
                return a.diff - b.diff;
              });
              
              // 选择最佳分割点
              const bestSplit = splitOptions[0];
              const bestSplitIndex = bestSplit.index;
              
              pageData.left_paras = allParas.slice(0, bestSplitIndex);
              pageData.right_paras = allParas.slice(bestSplitIndex);
              pageData.overflow = false;
            } 
            // 3. 正常情况：先左后右，填满左侧再填右侧
            else {
              // 填充左侧
              for (let i = 0; i < allParas.length; i++) {
                const tempParas = [...pageData.left_paras, allParas[i]];
                if (measureTextHeight(tempParas) <= totalHeight) {
                  pageData.left_paras.push(allParas[i]);
                } else {
                  break;
                }
              }
              
              // 剩余段落全部放入右侧
              const remainingForRight = allParas.slice(pageData.left_paras.length);
              for (let i = 0; i < remainingForRight.length; i++) {
                const tempParas = [...pageData.right_paras, remainingForRight[i]];
                if (measureTextHeight(tempParas) <= totalHeight) {
                  pageData.right_paras.push(remainingForRight[i]);
                } else {
                  break;
                }
              }
              
              // 检查是否有文本未被放置（溢出）
              const placedParasCount = pageData.left_paras.length + pageData.right_paras.length;
              pageData.overflow = placedParasCount < allParas.length;
            }

            break;
          }
        }

        return pageData;
      }

      // 渲染单页 - 增加溢出提示
      function renderPage(pageData, allParagraphs) {
        const pageElement = document.createElement('div');
        pageElement.className = 'custom-page';
        
        // 添加页码
        const pageNumber = document.createElement('div');
        pageNumber.className = 'page-number';
        pageNumber.textContent = `Page ${pageData.pageNumber}`;
        pageElement.appendChild(pageNumber);
        
        // 如果有文本溢出，显示页面级溢出提示
        if (pageData.overflow) {
          const overflowIndicator = document.createElement('div');
          overflowIndicator.className = 'page-overflow-indicator';
          overflowIndicator.textContent = 'out-page';
          pageElement.appendChild(overflowIndicator);
        }
        
        // 创建布局容器
        const layoutContainer = document.createElement('div');
        layoutContainer.className = 'layout-container';
        
        // 左侧容器
        const leftContainer = document.createElement('div');
        leftContainer.className = 'left-container';
        
        const leftWrapper = document.createElement('div');
        leftWrapper.className = 'content-wrapper';
        
        // 右侧容器
        const rightContainer = document.createElement('div');
        rightContainer.className = 'right-container';
        
        const rightWrapper = document.createElement('div');
        rightWrapper.className = 'content-wrapper';
        
        // 根据布局类型渲染内容
        switch (pageData.type) {
          case 'pic+text':
            // 左侧：图片 + 文本
            const imageContainer = document.createElement('div');
            imageContainer.className = 'image-container';
            imageContainer.innerHTML = '<div class="image-placeholder">image</div>';
            leftWrapper.appendChild(imageContainer);
            
            const leftTextHeight = 820 - 460 - 20; // 容器高度 - 图片高度 - 间距
            leftWrapper.appendChild(renderParagraphs(pageData.left_paras, leftTextHeight, true));
            
            // 右侧：文本
            rightWrapper.appendChild(renderParagraphs(pageData.right_paras, 820, true));
            break;
            
          case 'text+text':
            // 左侧：文本
            leftWrapper.appendChild(renderParagraphs(pageData.left_paras, 820, true));
            
            // 右侧：文本
            rightWrapper.appendChild(renderParagraphs(pageData.right_paras, 820, true));
            break;
        }
        
        leftContainer.appendChild(leftWrapper);
        rightContainer.appendChild(rightWrapper);
        layoutContainer.appendChild(leftContainer);
        layoutContainer.appendChild(rightContainer);
        pageElement.appendChild(layoutContainer);
        
        return pageElement;
      }

      // 渲染段落并检查溢出
      function renderParagraphs(paragraphs, maxHeight, showIndicator) {
        const container = document.createElement('div');
        container.className = 'text-container';
        
        paragraphs.forEach(paraText => {
          const paraElement = document.createElement('div');
          paraElement.className = 'paragraph';
          paraElement.textContent = paraText;
          container.appendChild(paraElement);
        });
        
        // 检查是否溢出
        const actualHeight = container.offsetHeight;
        if (showIndicator && actualHeight > maxHeight) {
          const indicator = document.createElement('div');
          indicator.className = 'overflow-indicator';
          indicator.textContent = 'overflow';
          container.appendChild(indicator);
        }
        
        return container;
      }

      // 测量文本高度
      function measureTextHeight(paragraphs) {
        const measureContainer = document.getElementById('measureContainer');
        measureContainer.innerHTML = '';
        
        paragraphs.forEach(paraText => {
          const paraElement = document.createElement('div');
          paraElement.className = 'paragraph';
          paraElement.textContent = paraText;
          measureContainer.appendChild(paraElement);
        });
        
        return measureContainer.offsetHeight;
      }
    });
  </script>
</body>

</html>
    
