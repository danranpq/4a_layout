<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>Text and Image Layout Generator with Pagination</title>
  <style>
    /* Import custom font */
    @font-face {
      font-family: 'URWGroteskWid-Lig';
      src: url('URWGroteskWid-Lig.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
    }

    /* Center the main heading */
    h1 {
      text-align: center;
      margin: 20px 0;
      font-family: 'URWGroteskWid-Lig', sans-serif;
    }

    body {
      margin: 0;
      padding: 20px;
      overflow-x: auto;
      font-family: Arial, sans-serif;
      background-color: #f5f5f5;
    }

    .content-area {
      width: 1800px;
      height: 920px;
      margin: 20px auto;
      position: relative;
      border: 1px solid #ccc;
      overflow: hidden;
      background-color: #fff;
      box-sizing: border-box;
      padding: 50px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }


    .layout-container {
      width: 1700px;
      height: 820px;
      box-sizing: border-box;
      display: flex;
      gap: 100px; /* 左右容器间隔100px */
      position: relative;
    }

    .left-container,
    .right-container {
      width: 800px;
      height: 820px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      border: 2px dashed #dee2e6;
      border-radius: 8px;
      position: relative;
      background-color: #fafafa;
    }

    /* 居中对齐 */
    .left-container {
      justify-content: center;
      align-items: center;
    }

    .right-container {
      justify-content: center;
      align-items: center;
    }

    .image-container {
      width: 100%;
      display: flex;
      justify-content: center;
      margin-bottom: 20px;
    }

    .image-placeholder {
      width: 800px;
      height: 460px;
      background-color: #f0f0f0;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 24px;
      color: #999;
      border: 2px solid #ddd;
    }

    .image-placeholder.small {
      width: 370px;
      height: 370px;
    }

    .text-area {
      width: 800px;
      font-family: 'URWGroteskWid-Lig', sans-serif;
      font-size: 41px;
      font-weight: normal;
      line-height: 50px;
      letter-spacing: 0px;
      word-wrap: break-word;
    }

    /* 段落基础样式 */
    .paragraph {
      font-family: 'URWGroteskWid-Lig', sans-serif;
      font-size: 41px;
      font-weight: normal;
      line-height: 50px;
      letter-spacing: 0px;
      word-wrap: break-word;
      width: 100%;
      margin-bottom: 30px;
    }

    .paragraph:last-child {
      margin-bottom: 0;
    }

   .control-panel {
      width: 1800px;
      margin: 20px auto;
      padding: 20px;
      background-color: #fff;
      border-radius: 8px;
      box-sizing: border-box;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }


    .row {
      display: flex;
      gap: 20px;
    }

    .column {
      flex: 1;
    }

    textarea {
      width: 100%;
      height: 200px;
      padding: 12px;
      box-sizing: border-box;
      font-size: 14px;
      line-height: 1.5;
      font-family: monospace;
      border: 1px solid #ddd;
      border-radius: 4px;
      resize: vertical;
    }


    button {
      padding: 10px 20px;
      font-size: 14px;
      margin-top: 10px;
      cursor: pointer;
      border: none;
      border-radius: 4px;
      transition: background-color 0.3s;
    }

    #generateBtn {
      background-color: #165DFF;
      color: white;
    }

    #generateBtn:hover {
      background-color: #0E42CC;
    }

    .checkbox-group {
      margin-bottom: 20px;
    }

    /* Hidden measurement container - for accurate text height calculation */
    #measureContainer {
      position: absolute;
      visibility: hidden;
      width: 800px;
      font-family: 'URWGroteskWid-Lig', sans-serif;
      font-size: 41px;
      line-height: 50px;
      word-wrap: break-word;
      top: -1000px;
    }

    #measureContainer .paragraph {
      font-family: 'URWGroteskWid-Lig', sans-serif;
      font-size: 41px;
      font-weight: normal;
      line-height: 50px;
      letter-spacing: 0px;
      word-wrap: break-word;
      margin-bottom: 30px;
    }

    #measureContainer .paragraph:last-child {
      margin-bottom: 0;
    }
    
    /* Loading indicator */
    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255,255,255,.3);
      border-radius: 50%;
      border-top-color: white;
      animation: spin 1s ease-in-out infinite;
      margin-right: 8px;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* 超出指示器 */
    .overflow-indicator {
      position: absolute;
      bottom: -25px;
      left: 0;
      width: 100%;
      text-align: center;
      color: #ff4d4f;
      font-size: 16px;
      font-family: sans-serif;
    }
    
    /* 内容包装器 - 用于居中内容 */
    .content-wrapper {
      width: 100%;
      max-height: 100%;
      overflow: hidden;
      position: relative;
    }
    
    /* 文本容器 - 用于控制文本溢出 */
    .text-container {
      width: 100%;
      position: relative;
    }
    
    /* 分页控件 */
    .pagination {
      display: flex;
      justify-content: center;
      margin-top: 20px;
      gap: 10px;
    }
    
    .pagination button {
      padding: 8px 16px;
      background-color: #f0f0f0;
      color: #333;
      border: 1px solid #ccc;
    }
    
    .pagination button.active {
      background-color: #165DFF;
      color: white;
      border-color: #165DFF;
    }
    
    .pagination button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .page-info {
      text-align: center;
      margin-top: 10px;
      font-size: 16px;
    }
    
    /* 页面容器 */
    .page {
      display: none;
      width: 100%;
      height: 100%;
    }
    
    .page.active {
      display: flex;
    }

    /* Tab容器样式：控制按钮整体位置，与原页面宽度对齐 */
    .tab-container {
      width: 1800px; 
      margin: 0 auto; 
      padding-top: 20px; 
    }

    .tab-btn {
      padding: 10px 25px;
      font-size: 16px;
      border: none; 
      border-radius: 4px 4px 0 0; 
      cursor: pointer; 
      background-color: #f0f0f0; 
      transition: background-color 0.3s; 
      margin-right: 5px; 
    }


    .tab-btn.active {
      background-color: #165DFF; 
      color: white; 
      font-weight: 500;
    }

    .tab-btn:hover:not(.active) {
      background-color: #e0e0e0; 
    }
  </style>
</head>

<body>
   <!-- Tab按钮容器：包裹两个切换按钮 -->
   <div class="tab-container">
    <button class="tab-btn" id="batchModifyBtn">batch modify</button>
    <button class="tab-btn active" id="smallModifyBtn">small modify</button>
  </div>

  <h1>Text and Image Layout Generator with Pagination</h1>

  <!-- Display area -->
  <div class="content-area">
    <div id="layoutDisplay" class="layout-container">
      Please enter text and click "Generate Layout" to view the result
    </div>
  </div>

  <!-- Pagination controls -->
  <div class="pagination" id="pagination" style="display: none;">
    <button id="prevPage">&lt; Previous</button>
    <button id="nextPage">Next &gt;</button>
  </div>
  <div class="page-info" id="pageInfo" style="display: none;">Page 1 of 1</div>

  <!-- Control panel -->
  <div class="control-panel">
    <div class="row">
      <div class="column">
        <label for="textInput">Enter Text</label><br>
        <textarea id="textInput" placeholder="Enter text content. Paragraphs will be automatically separated by line breaks">Ming got off the school bus and walked home next to Mum. Mrs Green had set the class a project for homework and Ming was cross.
"Mum, it's not fair," Ming complained. "Mrs Green has set us a project for homework, and we have to finish it by Monday. I wanted to spend the weekend playing with my toys or going to the park, not learning about dinosaurs!"
"Sorry," said Mum. "You will need to work on your project."
Ming told Mum all about the project. Everyone had to choose an unusual animal to write about.
"The only unusual animal I can think of is a dinosaur and I don't like dinosaurs," he said sadly. "I would rather learn to play football!" Ming added.
"I know, we can go to the zoo!" said Mum.
On Saturday morning, Mum, Dad and Ming got into the car. Then they went to the zoo.
First, they saw giant pandas. Then they saw lions and tigers. After lunch, they saw the penguins.
Ming woke up early on Sunday morning. He wanted to work on his project. Ming worked very hard all morning.
"We can go to the park after lunch," Mum told Ming.
"No, thank you. I want to spend more time on my project. I can't wait to show it to Mrs Green. I didn't know that there are birds that cannot fly. Penguins are so cool."
Ming was the first student in the classroom on Monday morning!</textarea>
      </div>
      <!--  # 注释掉布局选择，自动布局时候布局选择是固定的，得控制布局才能算
      <div class="column">
        <div class="checkbox-group">
          <label>
            <input type="checkbox" id="hasImage" checked> Include Image
          </label>
        </div>
        <div class="checkbox-group" id="imageSizeGroup">
          <label>
            <input type="checkbox" id="useSmallImage"> Use small image
          </label>
        </div>
       -->
        <button id="generateBtn">
          <span id="buttonText">Generate Layout</span>
          <span id="loadingIndicator" class="loading" style="display:none;"></span>
        </button>
      </div>
    </div>
  </div>

  <!-- Hidden measurement container - key for accurate text height calculation -->
  <div id="measureContainer"></div>

  <script>
    // Initialize page
    document.addEventListener('DOMContentLoaded', function () {
      // Set fixed zoom to 33%
      document.body.style.zoom = "33%";

      // Tab 按钮
      // 1. 获取Tab按钮（需确保HTML中已添加Tab按钮元素）
      const batchModifyBtn = document.getElementById('batchModifyBtn');
      const smallModifyBtn = document.getElementById('smallModifyBtn');

      // 2. batch modify按钮点击：切换到当前页面（保持样式激活）
      batchModifyBtn.addEventListener('click', function() {
        batchModifyBtn.classList.add('active');
        smallModifyBtn.classList.remove('active');
        window.location.href = 'index.html'; // 子页面文件名需和实际一致
      });

      // 3. small modify按钮点击：跳转到子页面+切换样式
      smallModifyBtn.addEventListener('click', function() {
        smallModifyBtn.classList.add('active');
        batchModifyBtn.classList.remove('active');
      });


      // Get DOM elements
      const generateBtn = document.getElementById('generateBtn');
      const textInput = document.getElementById('textInput');
      const hasImage = document.getElementById('hasImage');
      const useSmallImage = document.getElementById('useSmallImage');
      const imageSizeGroup = document.getElementById('imageSizeGroup');
      const layoutDisplay = document.getElementById('layoutDisplay');
      const measureContainer = document.getElementById('measureContainer');
      const buttonText = document.getElementById('buttonText');
      const loadingIndicator = document.getElementById('loadingIndicator');
      const pagination = document.getElementById('pagination');
      const prevPageBtn = document.getElementById('prevPage');
      const nextPageBtn = document.getElementById('nextPage');
      const pageInfo = document.getElementById('pageInfo');
      
      // Track font loading state
      let fontLoaded = false;
      let currentPage = 0;
      let totalPages = 0;
      let pagesData = [];
      
      // Check if custom font is available
      function checkFontLoaded() {
        // Create test elements
        const testElement = document.createElement('span');
        testElement.style.position = 'absolute';
        testElement.style.visibility = 'hidden';
        testElement.style.fontFamily = 'sans-serif';
        testElement.style.fontSize = '20px';
        testElement.textContent = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        
        const referenceElement = testElement.cloneNode(true);
        referenceElement.style.fontFamily = 'URWGroteskWid-Lig, sans-serif';
        
        document.body.appendChild(testElement);
        document.body.appendChild(referenceElement);
        
        // If widths are different, font is loaded
        const isLoaded = testElement.offsetWidth !== referenceElement.offsetWidth;
        
        // Clean up
        document.body.removeChild(testElement);
        document.body.removeChild(referenceElement);
        
        return isLoaded;
      }
      
      // Wait for font to load with timeout
      function waitForFontLoad() {
        return new Promise((resolve) => {
          // Check immediately
          if (checkFontLoaded()) {
            fontLoaded = true;
            resolve(true);
            return;
          }
          
          // Check periodically
          const interval = setInterval(() => {
            if (checkFontLoaded()) {
              clearInterval(interval);
              fontLoaded = true;
              resolve(true);
            }
          }, 100);
          
          // Timeout after 3 seconds
          setTimeout(() => {
            clearInterval(interval);
            console.warn('Font did not load within 3 seconds, using fallback');
            resolve(false);
            fontLoaded = true; // 强制设置为已加载，即使字体未加载也继续
          }, 3000);
        });
      }

      // Toggle image size option visibility based on include image checkbox
      hasImage.addEventListener('change', function () {
        imageSizeGroup.style.display = this.checked ? 'block' : 'none';
      });

      // Bind generate button event
      generateBtn.addEventListener('click', async function() {
        // Show loading state
        buttonText.textContent = 'Generating...';
        loadingIndicator.style.display = 'inline-block';
        generateBtn.disabled = true;
        
        try {
          // Ensure font is loaded before generating layout
          if (!fontLoaded) {
            await waitForFontLoad();
          }
          generateLayout();
        } finally {
          // Restore button state
          buttonText.textContent = 'Generate Layout';
          loadingIndicator.style.display = 'none';
          generateBtn.disabled = false;
        }
      });

      // Pagination event handlers
      prevPageBtn.addEventListener('click', function() {
        if (currentPage > 0) {
          showPage(currentPage - 1);
        }
      });
      
      nextPageBtn.addEventListener('click', function() {
        if (currentPage < totalPages - 1) {
          showPage(currentPage + 1);
        }
      });

      // Show specific page
      function showPage(pageIndex) {
        currentPage = pageIndex;
        
        // Update pagination controls
        prevPageBtn.disabled = currentPage === 0;
        nextPageBtn.disabled = currentPage === totalPages - 1;
        
        // Update page info
        pageInfo.textContent = `Page ${currentPage + 1} of ${totalPages}`;
        
        // Render the page
        renderPage(pagesData[currentPage]);
      }

      // Main layout generation function
      function generateLayout() {
        // Get input text and split into paragraphs
        const text = textInput.value.trim();
        if (!text) {
          layoutDisplay.innerHTML = 'Please enter text content';
          return;
        }

        // Split paragraphs by line breaks and clean up
        const paragraphs = text.split(/\n+/)
          .filter(para => para.trim() !== '')
          .map(para => para.replace(/^- /, '').trim()); // Remove bullet points if present

        // Calculate layout pages
        pagesData = calculatePages(paragraphs, hasImage.checked, useSmallImage.checked);
        totalPages = pagesData.length;
        
        if (totalPages === 0) {
          layoutDisplay.innerHTML = 'No content to display';
          pagination.style.display = 'none';
          pageInfo.style.display = 'none';
          return;
        }
        
        // Show first page
        showPage(0);
        
        // Show pagination controls if multiple pages
        if (totalPages > 1) {
          pagination.style.display = 'flex';
          pageInfo.style.display = 'block';
        } else {
          pagination.style.display = 'none';
          pageInfo.style.display = 'none';
        }
      }

      // Accurately measure text height
      function measureTextHeight(paragraphs) {
        // Set text to measurement container
        measureContainer.innerHTML = '';

        // Create paragraph container
        const container = document.createElement('div');
        container.className = 'text-area';

        // Add all paragraphs
        paragraphs.forEach((para, index) => {
          const paraElement = document.createElement('div');
          paraElement.className = 'paragraph';
          paraElement.textContent = para;
          container.appendChild(paraElement);
        });

        measureContainer.appendChild(container);
        
        // Force reflow before measuring
        container.offsetHeight; // Trigger reflow
        
        // Get actual rendered height
        const height = container.offsetHeight;
        return height;
      }

      // Calculate pages - FIXED VERSION
      function calculatePages(paragraphs, hasImage, useSmallImage) {
        const pages = [];
        
        // No image case
        if (!hasImage) {
          let remainingParas = [...paragraphs];
          
          while (remainingParas.length > 0) {
            const pageParas = [];
            let currentHeight = 0;
            const maxHeight = 820; // Container height
            
            for (let i = 0; i < remainingParas.length; i++) {
              const tempParas = [...pageParas, remainingParas[i]];
              const tempHeight = measureTextHeight(tempParas);
              
              if (tempHeight <= maxHeight) {
                pageParas.push(remainingParas[i]);
                currentHeight = tempHeight;
              } else {
                break;
              }
            }
            
            if (pageParas.length === 0 && remainingParas.length > 0) {
              // Even a single paragraph doesn't fit, add it anyway
              pageParas.push(remainingParas[0]);
            }
            
            // Remove used paragraphs
            remainingParas = remainingParas.slice(pageParas.length);
            
            pages.push({
              type: 'text_only',
              left_paras: pageParas,
              right_paras: [],
              useSmallImage: false
            });
          }
          
          return pages;
        }
        
        // With image case
        let remainingParas = [...paragraphs];
        
        while (remainingParas.length > 0) {
          const pageData = {
            type: 'image_with_text',
            left_paras: [],
            right_paras: [],
            useSmallImage: useSmallImage
          };
          
          // Determine image dimensions based on selection
          const imageHeight = useSmallImage ? 370 : 460;
          const imageGap = 20;
          const leftAvailableHeight = 820 - imageHeight - imageGap;
          
          // Special case: if only one paragraph remains, put it on the right side
          if (remainingParas.length === 1) {
            pageData.right_paras = [remainingParas[0]];
            remainingParas = [];
            pages.push(pageData);
            continue;
          }
          
          // First try to add paragraphs to left side (under image)
          for (let i = 0; i < remainingParas.length; i++) {
            const tempParas = [...pageData.left_paras, remainingParas[i]];
            const tempHeight = measureTextHeight(tempParas);
            
            if (tempHeight <= leftAvailableHeight) {
              pageData.left_paras.push(remainingParas[i]);
            } else {
              break;
            }
          }
          
          // Remove used paragraphs from left side
          remainingParas = remainingParas.slice(pageData.left_paras.length);
          
          // Add paragraphs to right side
          const rightAvailableHeight = 820;
          
          for (let i = 0; i < remainingParas.length; i++) {
            const tempParas = [...pageData.right_paras, remainingParas[i]];
            const tempHeight = measureTextHeight(tempParas);
            
            if (tempHeight <= rightAvailableHeight) {
              pageData.right_paras.push(remainingParas[i]);
            } else {
              break;
            }
          }
          
          // Remove used paragraphs from right side
          remainingParas = remainingParas.slice(pageData.right_paras.length);
          
          // If no content was added to right side and left side has content,
          // try to balance by moving some content from left to right
          if (pageData.right_paras.length === 0 && pageData.left_paras.length > 1) {
            // Find the optimal split point
            let splitIndex = 0;
            
            for (let i = 1; i < pageData.left_paras.length; i++) {
              const leftPart = pageData.left_paras.slice(0, i);
              const rightPart = pageData.left_paras.slice(i);
              
              const leftHeight = measureTextHeight(leftPart);
              const rightHeight = measureTextHeight(rightPart);
              
              // Check if both parts fit in their respective containers
              if (leftHeight <= leftAvailableHeight && rightHeight <= rightAvailableHeight) {
                splitIndex = i;
                break;
              }
            }
            
            // If we found a valid split, move content to right side
            if (splitIndex > 0) {
              pageData.right_paras = pageData.left_paras.slice(splitIndex);
              pageData.left_paras = pageData.left_paras.slice(0, splitIndex);
            } else {
              // If no split found, move all content to right side for the last paragraph
              if (remainingParas.length === 0) {
                pageData.right_paras = [...pageData.left_paras];
                pageData.left_paras = [];
              }
            }
          }
          
          pages.push(pageData);
        }
        
        return pages;
      }

      // Render paragraph elements
      function renderParagraphs(paragraphs, containerHeight, isOverflow = false) {
        if (!paragraphs || paragraphs.length === 0) return null;

        const container = document.createElement('div');
        container.className = 'text-container';

        paragraphs.forEach(para => {
          const paraElement = document.createElement('div');
          paraElement.className = 'paragraph';
          paraElement.textContent = para;
          container.appendChild(paraElement);
        });

        // Check if content overflows
        const contentHeight = container.scrollHeight;
        if (contentHeight > containerHeight && isOverflow) {
          const indicator = document.createElement('div');
          indicator.className = 'overflow-indicator';
          indicator.textContent = 'Content exceeds container';
          container.appendChild(indicator);
        }

        return container;
      }

      // Render a single page
      function renderPage(pageData) {
        // Create main container
        const container = document.createElement('div');
        container.className = 'page active';

        // Determine image class based on size
        const imageClass = pageData.useSmallImage ? 'image-placeholder small' : 'image-placeholder';

        switch (pageData.type) {
          case 'text_only':
            // Text only layout: text split into two columns
            const leftContainer1 = document.createElement('div');
            leftContainer1.className = 'left-container';
            
            const leftWrapper1 = document.createElement('div');
            leftWrapper1.className = 'content-wrapper';
            leftWrapper1.appendChild(renderParagraphs(pageData.left_paras, 820, true));
            leftContainer1.appendChild(leftWrapper1);

            const rightContainer1 = document.createElement('div');
            rightContainer1.className = 'right-container';
            
            const rightWrapper1 = document.createElement('div');
            rightWrapper1.className = 'content-wrapper';
            rightWrapper1.appendChild(renderParagraphs(pageData.right_paras, 820, true));
            rightContainer1.appendChild(rightWrapper1);

            // 创建布局容器并添加左右容器
            const layoutContainer1 = document.createElement('div');
            layoutContainer1.className = 'layout-container';
            layoutContainer1.appendChild(leftContainer1);
            layoutContainer1.appendChild(rightContainer1);
            
            container.appendChild(layoutContainer1);
            break;

          case 'image_with_text':
            // Image + text on left, text on right layout
            const leftContainer2 = document.createElement('div');
            leftContainer2.className = 'left-container';
            
            const leftWrapper2 = document.createElement('div');
            leftWrapper2.className = 'content-wrapper';
            
            // Only show image if there's content on left side
            if (pageData.left_paras && pageData.left_paras.length > 0) {
              // Create image container for centering
              const imageContainer = document.createElement('div');
              imageContainer.className = 'image-container';
              imageContainer.innerHTML = `<div class="${imageClass}">image</div>`;
              
              leftWrapper2.appendChild(imageContainer);
              
              // Add text content
              const textHeight = 820 - (pageData.useSmallImage ? 370 : 460) - 20;
              leftWrapper2.appendChild(renderParagraphs(pageData.left_paras, textHeight, true));
            } else {
              // If no content on left, just show centered image
              leftContainer2.style.justifyContent = 'center';
              leftWrapper2.innerHTML = `<div class="${imageClass}">image</div>`;
            }
            
            leftContainer2.appendChild(leftWrapper2);

            const rightContainer2 = document.createElement('div');
            rightContainer2.className = 'right-container';
            
            const rightWrapper2 = document.createElement('div');
            rightWrapper2.className = 'content-wrapper';
            rightWrapper2.appendChild(renderParagraphs(pageData.right_paras, 820, true));
            rightContainer2.appendChild(rightWrapper2);

            // 创建布局容器并添加左右容器
            const layoutContainer2 = document.createElement('div');
            layoutContainer2.className = 'layout-container';
            layoutContainer2.appendChild(leftContainer2);
            layoutContainer2.appendChild(rightContainer2);
            
            container.appendChild(layoutContainer2);
            break;
        }

        // Update display area
        layoutDisplay.innerHTML = '';
        layoutDisplay.appendChild(container);
      }
      
      // Generate initial layout on page load
      generateBtn.click();
    });
  </script>

  <!-- 在这里添加缓存清除脚本 -->
    <script>
    // 强制浏览器不使用缓存版本
    if (window.performance) {
    if (performance.navigation.type === 1) {
    // 如果是刷新操作，重新加载并清除缓存
    window.location.reload(true);
        }
    }

  // 或者更简单的方法：每次加载都添加随机参数
   document.addEventListener('DOMContentLoaded', function() {
     const links = document.querySelectorAll('link[rel="stylesheet"]');
     const scripts = document.querySelectorAll('script[src]');
      
     const timestamp = '?v=' + new Date().getTime();
      
     links.forEach(link => {
       const href = link.href;
       if (href && href.indexOf('?') === -1) {
         link.href = href + timestamp;
       }
      });
      
     scripts.forEach(script => {
        const src = script.src;
        if (src && src.indexOf('?') === -1 && !script.hasAttribute('data-no-cache')) {
          script.src = src + timestamp;
        }
      });
    });
    </script>

</body>

</html>
